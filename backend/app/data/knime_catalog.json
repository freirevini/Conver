{
    "version": "4.5.2",
    "generated_at": "2026-02-04T19:50:00Z",
    "description": "KNIME Node Catalog for deterministic Python translation",
    "operator_mappings": {
        "EQUALS": "==",
        "NOT_EQUALS": "!=",
        "GREATER_THAN": ">",
        "LESS_THAN": "<",
        "GREATER_OR_EQUAL": ">=",
        "LESS_OR_EQUAL": "<=",
        "CONTAINS": ".str.contains",
        "NOT_CONTAINS": "~.str.contains",
        "MATCHES_PATTERN": ".str.match",
        "STARTS_WITH": ".str.startswith",
        "ENDS_WITH": ".str.endswith",
        "IS_MISSING": ".isna()",
        "IS_NOT_MISSING": ".notna()",
        "IN_RANGE": "between",
        "IN_LIST": ".isin"
    },
    "string_functions": {
        "join": {
            "python": ".str.cat",
            "args": "sep='{sep}'"
        },
        "substr": {
            "python": ".str[{start}:{end}]",
            "args": "start, end"
        },
        "upperCase": {
            "python": ".str.upper()",
            "args": null
        },
        "lowerCase": {
            "python": ".str.lower()",
            "args": null
        },
        "capitalize": {
            "python": ".str.capitalize()",
            "args": null
        },
        "trim": {
            "python": ".str.strip()",
            "args": null
        },
        "strip": {
            "python": ".str.strip('{chars}')",
            "args": "chars"
        },
        "length": {
            "python": ".str.len()",
            "args": null
        },
        "indexOf": {
            "python": ".str.find('{pattern}')",
            "args": "pattern"
        },
        "lastIndexOf": {
            "python": ".str.rfind('{pattern}')",
            "args": "pattern"
        },
        "replace": {
            "python": ".str.replace('{old}', '{new}')",
            "args": "old, new"
        },
        "regexReplace": {
            "python": ".str.replace('{pattern}', '{replacement}', regex=True)",
            "args": "pattern, replacement"
        },
        "regexMatcher": {
            "python": ".str.match('{pattern}')",
            "args": "pattern"
        },
        "contains": {
            "python": ".str.contains('{pattern}')",
            "args": "pattern"
        },
        "split": {
            "python": ".str.split('{sep}')",
            "args": "sep"
        },
        "padLeft": {
            "python": ".str.zfill({width})",
            "args": "width"
        },
        "padRight": {
            "python": ".str.ljust({width})",
            "args": "width"
        },
        "reverse": {
            "python": ".str[::-1]",
            "args": null
        },
        "toInt": {
            "python": ".astype(int)",
            "args": null
        },
        "toDouble": {
            "python": ".astype(float)",
            "args": null
        },
        "toString": {
            "python": ".astype(str)",
            "args": null
        }
    },
    "math_functions": {
        "ABS": {
            "python": "np.abs",
            "args": "x"
        },
        "ROUND": {
            "python": "np.round",
            "args": "x, decimals"
        },
        "FLOOR": {
            "python": "np.floor",
            "args": "x"
        },
        "CEIL": {
            "python": "np.ceil",
            "args": "x"
        },
        "SQRT": {
            "python": "np.sqrt",
            "args": "x"
        },
        "POW": {
            "python": "np.power",
            "args": "x, y"
        },
        "LOG": {
            "python": "np.log",
            "args": "x"
        },
        "LOG10": {
            "python": "np.log10",
            "args": "x"
        },
        "LOG2": {
            "python": "np.log2",
            "args": "x"
        },
        "EXP": {
            "python": "np.exp",
            "args": "x"
        },
        "SIN": {
            "python": "np.sin",
            "args": "x"
        },
        "COS": {
            "python": "np.cos",
            "args": "x"
        },
        "TAN": {
            "python": "np.tan",
            "args": "x"
        },
        "ASIN": {
            "python": "np.arcsin",
            "args": "x"
        },
        "ACOS": {
            "python": "np.arccos",
            "args": "x"
        },
        "ATAN": {
            "python": "np.arctan",
            "args": "x"
        },
        "MIN": {
            "python": "min",
            "args": "x, y"
        },
        "MAX": {
            "python": "max",
            "args": "x, y"
        },
        "MOD": {
            "python": "%",
            "args": "x, y"
        },
        "SIGN": {
            "python": "np.sign",
            "args": "x"
        },
        "RAND": {
            "python": "np.random.random()",
            "args": null
        },
        "IF": {
            "python": "np.where",
            "args": "condition, true_val, false_val"
        }
    },
    "type_mappings": {
        "StringCell": {
            "pandas": "object",
            "python": "str"
        },
        "IntCell": {
            "pandas": "int64",
            "python": "int"
        },
        "LongCell": {
            "pandas": "int64",
            "python": "int"
        },
        "DoubleCell": {
            "pandas": "float64",
            "python": "float"
        },
        "BooleanCell": {
            "pandas": "bool",
            "python": "bool"
        },
        "DateAndTimeCell": {
            "pandas": "datetime64[ns]",
            "python": "datetime"
        },
        "LocalDateCell": {
            "pandas": "datetime64[ns]",
            "python": "date"
        },
        "LocalTimeCell": {
            "pandas": "object",
            "python": "time"
        },
        "LocalDateTimeCell": {
            "pandas": "datetime64[ns]",
            "python": "datetime"
        },
        "ListCell": {
            "pandas": "object",
            "python": "list"
        },
        "SetCell": {
            "pandas": "object",
            "python": "set"
        },
        "BinaryObjectCell": {
            "pandas": "object",
            "python": "bytes"
        }
    },
    "operators": {
        "EQUALS": "==",
        "NOT_EQUALS": "!=",
        "GREATER_THAN": ">",
        "LESS_THAN": "<",
        "GREATER_OR_EQUAL": ">=",
        "LESS_OR_EQUAL": "<="
    },
    "nodes": {
        "org.knime.base.node.io.csvreader.CSVReaderNodeFactory": {
            "name": "CSV Reader (Legacy)",
            "category": "IO",
            "subcategory": "Read",
            "complexity": "LOW",
            "template": "{output_var} = pd.read_csv('{file_path}', sep='{separator}')",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true
                },
                "separator": {
                    "type": "string",
                    "default": ","
                }
            },
            "output_type": "DataFrame"
        },
        "org.knime.base.node.preproc.filter.row.RowFilterNodeFactory": {
            "name": "Row Filter",
            "category": "Manipulation",
            "subcategory": "Row",
            "complexity": "MEDIUM",
            "template": "{output_var} = {input_var}[{condition}]",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "column": {
                    "type": "string",
                    "required": true
                },
                "operator": {
                    "type": "string",
                    "required": true
                },
                "value": {
                    "type": "auto",
                    "required": true
                }
            }
        },
        "org.knime.base.node.io.filereader.FileReaderNodeFactory": {
            "name": "CSV Reader",
            "category": "IO",
            "subcategory": "Read",
            "complexity": "LOW",
            "template": "{output_var} = pd.read_csv('{file_path}', sep='{separator}', header={header}, skiprows={skip_lines})",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/url/path"
                },
                "separator": {
                    "type": "string",
                    "default": ",",
                    "xml_path": "model/column_delimiter"
                },
                "header": {
                    "type": "integer",
                    "default": 0,
                    "xml_path": "model/has_column_header"
                },
                "skip_lines": {
                    "type": "integer",
                    "default": 0,
                    "xml_path": "model/skip_lines"
                }
            },
            "output_type": "DataFrame"
        },
        "org.knime.base.node.io.csvwriter.CSVWriterNodeFactory": {
            "name": "CSV Writer",
            "category": "IO",
            "subcategory": "Write",
            "complexity": "LOW",
            "template": "{input_var}.to_csv('{file_path}', sep='{separator}', index=False)",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/url/path"
                },
                "separator": {
                    "type": "string",
                    "default": ",",
                    "xml_path": "model/column_delimiter"
                }
            }
        },
        "org.knime.base.node.io.filehandling.table.reader.TableReaderNodeFactory": {
            "name": "Table Reader",
            "category": "IO",
            "subcategory": "Read",
            "complexity": "LOW",
            "template": "{output_var} = pd.read_pickle('{file_path}')",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/file_path"
                }
            },
            "output_type": "DataFrame"
        },
        "org.knime.base.node.io.filehandling.table.writer.TableWriterNodeFactory": {
            "name": "Table Writer",
            "category": "IO",
            "subcategory": "Write",
            "complexity": "LOW",
            "template": "{input_var}.to_pickle('{file_path}')",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/file_path"
                }
            }
        },
        "org.knime.ext.poi3.node.io.filehandling.excel.reader.ExcelTableReaderNodeFactory": {
            "name": "Excel Reader",
            "category": "IO",
            "subcategory": "Read",
            "complexity": "LOW",
            "template": "{output_var} = pd.read_excel('{file_path}', sheet_name={sheet_name})",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "file_path": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/file_path"
                },
                "sheet_name": {
                    "type": "string",
                    "default": "0",
                    "xml_path": "model/sheet_name"
                }
            },
            "output_type": "DataFrame"
        },
        "org.knime.base.node.preproc.filter.column.DataColumnSpecFilterNodeFactory": {
            "name": "Column Filter",
            "category": "Manipulation",
            "subcategory": "Column",
            "complexity": "LOW",
            "template": "{output_var} = {input_var}[{columns}]",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "columns": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/column_filter/included_names"
                }
            },
            "output_type": "DataFrame"
        },
        "org.knime.base.node.preproc.columnsplitter.ColumnSplitterNodeFactory": {
            "name": "Column Splitter",
            "category": "Manipulation",
            "subcategory": "Column",
            "complexity": "LOW",
            "template": "{output_var}_left = {input_var}[{include_columns}]\n{output_var}_right = {input_var}.drop(columns={include_columns})",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "include_columns": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/included_columns"
                }
            },
            "output_ports": 2
        },
        "org.knime.base.node.preproc.columnCombine.ColumnCombinerNodeFactory": {
            "name": "Column Combiner",
            "category": "Manipulation",
            "subcategory": "Column",
            "complexity": "LOW",
            "template": "{output_var} = {input_var}.copy()\n{output_var}['{new_column}'] = {input_var}[{columns}].astype(str).agg('{delimiter}'.join, axis=1)",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "columns": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/included_columns"
                },
                "new_column": {
                    "type": "string",
                    "default": "combined",
                    "xml_path": "model/new_column_name"
                },
                "delimiter": {
                    "type": "string",
                    "default": " ",
                    "xml_path": "model/delimiter"
                }
            }
        },
        "org.knime.base.node.preproc.filter.row.rowfilter.RowFilterNodeFactory": {
            "name": "Row Filter",
            "category": "Manipulation",
            "subcategory": "Row",
            "complexity": "MEDIUM",
            "template": "{output_var} = {input_var}[{condition}]",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "column": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/column"
                },
                "operator": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/operator"
                },
                "value": {
                    "type": "auto",
                    "required": true,
                    "xml_path": "model/value"
                }
            },
            "condition_builder": "build_row_filter_condition"
        },
        "org.knime.base.node.preproc.splitter.SplitterNodeFactory": {
            "name": "Row Splitter",
            "category": "Manipulation",
            "subcategory": "Row",
            "complexity": "MEDIUM",
            "template": "{output_var}_match = {input_var}[{condition}]\n{output_var}_nomatch = {input_var}[~({condition})]",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "column": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/column"
                },
                "operator": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/operator"
                },
                "value": {
                    "type": "auto",
                    "required": true,
                    "xml_path": "model/value"
                }
            },
            "output_ports": 2
        },
        "org.knime.base.node.preproc.duplicates.DuplicateRowFilterNodeFactory": {
            "name": "Duplicate Row Filter",
            "category": "Manipulation",
            "subcategory": "Row",
            "complexity": "LOW",
            "template": "{output_var} = {input_var}.drop_duplicates(subset={columns}, keep='{keep}')",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "columns": {
                    "type": "array",
                    "default": null,
                    "xml_path": "model/included_columns"
                },
                "keep": {
                    "type": "string",
                    "default": "first",
                    "options": [
                        "first",
                        "last",
                        false
                    ]
                }
            }
        },
        "org.knime.base.node.preproc.groupby.GroupByNodeFactory": {
            "name": "GroupBy",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "MEDIUM",
            "template": "{output_var} = {input_var}.groupby({group_columns}).agg({aggregations}).reset_index()",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "group_columns": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/group_columns"
                },
                "aggregations": {
                    "type": "dict",
                    "required": true,
                    "xml_path": "model/aggregation_settings"
                }
            },
            "aggregation_map": {
                "Sum": "sum",
                "Count": "count",
                "Mean": "mean",
                "Median": "median",
                "Min": "min",
                "Max": "max",
                "Std Dev": "std",
                "Variance": "var",
                "First": "first",
                "Last": "last"
            }
        },
        "org.knime.base.node.preproc.pivot.PivotNodeFactory": {
            "name": "Pivot",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "MEDIUM",
            "template": "{output_var} = {input_var}.pivot_table(index={index_cols}, columns='{pivot_col}', values={value_cols}, aggfunc='{aggfunc}')",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "index_cols": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/group_columns"
                },
                "pivot_col": {
                    "type": "string",
                    "required": true,
                    "xml_path": "model/pivot_column"
                },
                "value_cols": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/value_columns"
                },
                "aggfunc": {
                    "type": "string",
                    "default": "sum",
                    "xml_path": "model/aggregation"
                }
            }
        },
        "org.knime.base.node.preproc.joiner.Joiner3NodeFactory": {
            "name": "Joiner",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "MEDIUM",
            "template": "{output_var} = pd.merge({left_var}, {right_var}, left_on={left_cols}, right_on={right_cols}, how='{join_type}', suffixes=('', '{suffix}'))",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "left_cols": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/left_join_columns"
                },
                "right_cols": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/right_join_columns"
                },
                "join_type": {
                    "type": "string",
                    "default": "inner",
                    "options": [
                        "inner",
                        "left",
                        "right",
                        "outer"
                    ]
                },
                "suffix": {
                    "type": "string",
                    "default": "_right"
                }
            },
            "join_type_map": {
                "INNER": "inner",
                "LEFT_OUTER": "left",
                "RIGHT_OUTER": "right",
                "FULL_OUTER": "outer"
            }
        },
        "org.knime.base.node.preproc.crossjoiner.CrossJoinerNodeFactory": {
            "name": "Cross Joiner",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "LOW",
            "template": "{output_var} = {left_var}.merge({right_var}, how='cross')",
            "imports": [
                "import pandas as pd"
            ]
        },
        "org.knime.base.node.preproc.sorter.SorterNodeFactory": {
            "name": "Sorter",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "LOW",
            "template": "{output_var} = {input_var}.sort_values(by={sort_columns}, ascending={ascending})",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "sort_columns": {
                    "type": "array",
                    "required": true,
                    "xml_path": "model/sort_columns"
                },
                "ascending": {
                    "type": "boolean",
                    "default": true,
                    "xml_path": "model/ascending"
                }
            }
        },
        "org.knime.base.node.preproc.append.row.AppendedRowsNodeFactory": {
            "name": "Concatenate",
            "category": "Manipulation",
            "subcategory": "Row",
            "complexity": "LOW",
            "template": "{output_var} = pd.concat([{input_vars}], ignore_index=True)",
            "imports": [
                "import pandas as pd"
            ]
        },
        "org.knime.base.node.preproc.stringmanipulation.StringManipulationNodeFactory": {
            "name": "String Manipulation",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "HIGH",
            "requires_parser": "string_parser",
            "imports": [
                "import pandas as pd"
            ],
            "column_reference_pattern": "\\$([^$]+)\\$",
            "column_replacement": "df['{col}']"
        },
        "org.knime.base.node.preproc.javasnippet.JavaSnippetNodeFactory": {
            "name": "Math Formula",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "HIGH",
            "requires_parser": "math_parser",
            "imports": [
                "import pandas as pd",
                "import numpy as np"
            ],
            "column_reference_pattern": "\\$([^$]+)\\$",
            "column_replacement": "df['{col}']"
        },
        "org.knime.base.node.rules.engine.RuleEngineNodeFactory2": {
            "name": "Rule Engine",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "HIGH",
            "requires_parser": "rule_parser",
            "imports": [
                "import pandas as pd",
                "import numpy as np"
            ],
            "rule_pattern": "(.+)\\s*=>\\s*(.+)",
            "default_rule": "TRUE => "
        },
        "org.knime.base.expressions.node.ExpressionNodeFactory": {
            "name": "Column Expressions",
            "category": "Manipulation",
            "subcategory": "Column",
            "complexity": "HIGH",
            "requires_parser": "expression_parser",
            "imports": [
                "import pandas as pd",
                "import numpy as np"
            ]
        },
        "org.knime.base.node.preproc.pmml.missingval.MissingValueHandlerNodeFactory": {
            "name": "Missing Value",
            "category": "Manipulation",
            "subcategory": "Transform",
            "complexity": "LOW",
            "template": "{output_var} = {input_var}.fillna({fill_value})",
            "imports": [
                "import pandas as pd"
            ],
            "params": {
                "fill_value": {
                    "type": "auto",
                    "default": 0,
                    "xml_path": "model/fill_value"
                }
            }
        },
        "org.knime.base.node.flowvariable.tablerowtovariable.TableRowToVariableNodeFactory3": {
            "name": "Table Row to Variable Loop Start",
            "category": "Workflow Control",
            "subcategory": "Loops",
            "complexity": "MEDIUM",
            "template": "for {loop_var}, row in {input_var}.iterrows():\n    # Loop body here",
            "imports": [
                "import pandas as pd"
            ],
            "is_loop_start": true
        },
        "org.knime.base.node.preproc.columnlist.ColumnListLoopStartNodeFactory": {
            "name": "Column List Loop Start",
            "category": "Workflow Control",
            "subcategory": "Loops",
            "complexity": "MEDIUM",
            "template": "for {loop_var} in {input_var}.columns:\n    # Loop body here",
            "imports": [
                "import pandas as pd"
            ],
            "is_loop_start": true
        },
        "org.knime.base.node.flowvariable.loop.CountingLoopStartNodeFactory": {
            "name": "Counting Loop Start",
            "category": "Workflow Control",
            "subcategory": "Loops",
            "complexity": "LOW",
            "template": "for {loop_var} in range({start}, {end}, {step}):\n    # Loop body here",
            "params": {
                "start": {
                    "type": "integer",
                    "default": 0
                },
                "end": {
                    "type": "integer",
                    "required": true
                },
                "step": {
                    "type": "integer",
                    "default": 1
                }
            },
            "is_loop_start": true
        },
        "org.knime.base.node.switches.ifswitch.IFSwitchNodeFactory": {
            "name": "IF Switch",
            "category": "Workflow Control",
            "subcategory": "Switches",
            "complexity": "MEDIUM",
            "template": "if {condition}:\n    # True branch\nelse:\n    # False branch",
            "is_switch": true
        },
        "org.knime.base.node.switches.caseswitch.CaseSwitchNodeFactory": {
            "name": "CASE Switch",
            "category": "Workflow Control",
            "subcategory": "Switches",
            "complexity": "MEDIUM",
            "template": "match {variable}:\n    case {case1}:\n        # Case 1\n    case {case2}:\n        # Case 2\n    case _:\n        # Default",
            "is_switch": true
        },
        "org.knime.base.node.switches.emptytableswitch.EmptyTableSwitchNodeFactory": {
            "name": "Empty Table Switch",
            "category": "Workflow Control",
            "subcategory": "Switches",
            "complexity": "LOW",
            "template": "if {input_var}.empty:\n    # Empty branch\nelse:\n    # Non-empty branch",
            "imports": [
                "import pandas as pd"
            ],
            "is_switch": true
        }
    },
    "db_connectors": {
        "mysql": {
            "name": "MySQL Connector",
            "imports": [
                "import pandas as pd",
                "import mysql.connector"
            ],
            "template": "conn = mysql.connector.connect(\n    host='{host}',\n    database='{database}',\n    user='{user}',\n    password='{password}',\n    port={port}\n)\n{output_var} = pd.read_sql('{query}', conn)\nconn.close()"
        },
        "postgresql": {
            "name": "PostgreSQL Connector",
            "imports": [
                "import pandas as pd",
                "import psycopg2"
            ],
            "template": "conn = psycopg2.connect(\n    host='{host}',\n    database='{database}',\n    user='{user}',\n    password='{password}',\n    port={port}\n)\n{output_var} = pd.read_sql('{query}', conn)\nconn.close()"
        },
        "oracle": {
            "name": "Oracle Connector",
            "imports": [
                "import pandas as pd",
                "import cx_Oracle"
            ],
            "template": "dsn = cx_Oracle.makedsn('{host}', {port}, service_name='{service}')\nconn = cx_Oracle.connect(user='{user}', password='{password}', dsn=dsn)\n{output_var} = pd.read_sql('{query}', conn)\nconn.close()"
        },
        "h2": {
            "name": "H2 Connector",
            "imports": [
                "import pandas as pd",
                "import jaydebeapi"
            ],
            "template": "conn = jaydebeapi.connect(\n    'org.h2.Driver',\n    '{jdbc_url}',\n    ['{user}', '{password}']\n)\n{output_var} = pd.read_sql('{query}', conn)\nconn.close()"
        }
    }
}